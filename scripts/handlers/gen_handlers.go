// +build scripts

// This program generates /internal/api/handlers.go.
// It can be invoked by running go run -tags scripts scripts/handlers/gen_handlers.go

// Supported args:
// -print-only

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"allaboutapps.dev/aw/go-starter/scripts"
)

// https://blog.carlmjohnson.net/post/2016-11-27-how-to-use-go-generate/

var (
	HANDLERS_PACKAGE = "/internal/api/handlers"

	PATH_PROJECT_ROOT  = scripts.GetProjectRootDir()
	PATH_HANDLERS_ROOT = PATH_PROJECT_ROOT + HANDLERS_PACKAGE
	PATH_MOD_FILE      = PATH_PROJECT_ROOT + "/go.mod"
	PATH_HANDLERS_FILE = PATH_HANDLERS_ROOT + "/handlers.go"

	// <METHOD_PREFIXES>*<METHOD_SUFFIX> route must look like this
	METHOD_PREFIXES = []string{
		// https://swagger.io/specification/v2/ fixed fields: GET, PUT, POST, DELETE, OPTIONS, HEAD, PATCH
		"Get", "Put", "Post", "Delete", "Options", "Head", "Patch",
	}
	METHOD_SUFFIX = "Route"

	PACKAGE_TEMPLATE = template.Must(template.New("").Parse(`// Code generated by go run -tags scripts scripts/handlers/gen_handlers.go; DO NOT EDIT.
package handlers

import (
	"allaboutapps.dev/aw/go-starter/internal/api"
	{{- range .SubPkgs }}
	"{{ . }}"
	{{- end }}
	"github.com/labstack/echo/v4"
)

func AttachAllRoutes(s *api.Server) {
	// attach our routes
	s.Router.Routes = []*echo.Route{
		{{- range .Funcs }}
		{{ .PackageName }}.{{ .FunctionName }}(s),
		{{- end }}
	}
}
`))
)

type ResolvedFunction struct {
	FunctionName    string
	PackageName     string
	PackageNameFQDN string
}

type TempateData struct {
	SubPkgs []string
	Funcs   []ResolvedFunction
}

// get all functions in above handler packages
// that match <METHOD_PREFIXES>*<METHOD_SUFFIX>
func main() {

	printOnly := flag.Bool("print-only", false, "If specified, will only print our handlers without doing anything.")
	flag.Parse()

	funcs := []ResolvedFunction{}

	baseModuleName, err := scripts.GetModuleName(PATH_MOD_FILE)

	if err != nil {
		log.Fatal(err)
	}

	set := token.NewFileSet()

	err = filepath.Walk(PATH_HANDLERS_ROOT, func(path string, f os.FileInfo, err error) error {

		// ignore handler file to be generated
		// ignore directories
		// ignore non go files
		// ignore test go files
		if path == PATH_HANDLERS_FILE || f.IsDir() || strings.HasSuffix(path, ".go") == false || strings.HasSuffix(path, "test.go") {
			return nil
		}

		gofile, err := parser.ParseFile(set, path, nil, 0)

		if err != nil {
			fmt.Println("Failed to parse package:", err)
			os.Exit(1)
		}

		fileDir := filepath.Dir(path)
		packageNameFQDN := strings.Replace(fileDir, PATH_PROJECT_ROOT, baseModuleName, 1)

		for _, d := range gofile.Decls {

			if fn, isFn := d.(*ast.FuncDecl); isFn {

				fnName := fn.Name.String()

				for _, prefix := range METHOD_PREFIXES {
					if strings.HasPrefix(fnName, prefix) && strings.HasSuffix(fnName, METHOD_SUFFIX) {
						funcs = append(funcs, ResolvedFunction{
							FunctionName:    fnName,
							PackageName:     gofile.Name.Name,
							PackageNameFQDN: packageNameFQDN,
						})
					}
				}
			}
		}

		// fmt.Println(packageNameFQDN, path)

		return nil
	})

	if err != nil {
		log.Fatal(err)
	}

	// stable sort the functions
	// first PackageName then FunctionName
	sort.Slice(funcs[:], func(i, j int) bool {
		return funcs[i].PackageNameFQDN+funcs[i].FunctionName < funcs[j].PackageNameFQDN+funcs[j].FunctionName
	})

	// only add subPkg if there was actually a route within it found
	subPkgs := []string{}
	for _, fun := range funcs {

		mustAppend := true

		for _, a := range subPkgs {
			if a == fun.PackageNameFQDN {
				mustAppend = false
			}
		}

		if mustAppend == true {
			subPkgs = append(subPkgs, fun.PackageNameFQDN)
		}
	}

	if *printOnly == true {
		for _, function := range funcs {
			fmt.Println(function.PackageNameFQDN, function.FunctionName)
		}

		// bailout
		return
	}

	f, err := os.Create(PATH_HANDLERS_FILE)

	if err != nil {
		log.Fatal(err)
	}

	defer f.Close()

	PACKAGE_TEMPLATE.Execute(f, TempateData{
		SubPkgs: subPkgs,
		Funcs:   funcs,
	})

}
