//go:build scripts

// This program generates /internal/api/handlers.go.
// It can be invoked by running go run -tags scripts scripts/handlers/gen_handlers.go

// Supported args:
// -print-only

package handlers

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"allaboutapps.dev/aw/go-starter/scripts/internal/util"
)

// https://blog.carlmjohnson.net/post/2016-11-27-how-to-use-go-generate/

var (
	handlersPackage = "/internal/api/handlers"

	pathProjectRoot  = util.GetProjectRootDir()
	pathHandlersRoot = pathProjectRoot + handlersPackage
	pathModFile      = pathProjectRoot + "/go.mod"
	pathHandlersFile = pathHandlersRoot + "/handlers.go"

	// methodPrefixes defines all keywords that we search for in the handlers sub packages
	// <methodPrefixes>*<methodSuffix> must be the naming of the route (Capitalized)
	methodPrefixes = []string{
		// https://swagger.io/specification/v2/ fixed fields: GET, PUT, POST, DELETE, OPTIONS, HEAD, PATCH
		"Get", "Put", "Post", "Delete", "Options", "Head", "Patch",
	}
	methodSuffixes = []string{
		"Route", "RouteV*", // Wildcard '*' matches zero or more digits
	}

	packageTemplate = template.Must(template.New("").Parse(`// Code generated by go run -tags scripts scripts/handlers/gen_handlers.go; DO NOT EDIT.
package handlers

import (
	"allaboutapps.dev/aw/go-starter/internal/api"
	{{- range .SubPkgs }}
	"{{ . }}"
	{{- end }}
	"github.com/labstack/echo/v4"
)

func AttachAllRoutes(s *api.Server) {
	// attach our routes
	s.Router.Routes = []*echo.Route{
		{{- range .Funcs }}
		{{ .PackageName }}.{{ .FunctionName }}(s),
		{{- end }}
	}
}
`))
)

type ResolvedFunction struct {
	FunctionName    string
	PackageName     string
	PackageNameFQDN string
}

type TempateData struct {
	SubPkgs []string
	Funcs   []ResolvedFunction
}

// get all functions in above handler packages
// that match <methodPrefixes>*<methodSuffix>
func GenHandlers(printOnly bool) {
	funcs := []ResolvedFunction{}
	subPkgsMap := make(map[string]struct{}) // Collect unique package FQDNs here.

	baseModuleName, err := util.GetModuleName(pathModFile)
	if err != nil {
		log.Fatal(err)
	}

	// Build a single regex to match all desired function names
	prefixPart := strings.Join(methodPrefixes, "|")

	var suffixParts []string
	for _, suffixPattern := range methodSuffixes {
		if strings.HasSuffix(suffixPattern, "*") {
			// Wildcard '*' is defined to match zero or more digits.
			baseSuffix := strings.TrimSuffix(suffixPattern, "*")
			suffixParts = append(suffixParts, regexp.QuoteMeta(baseSuffix)+"[0-9]*")
		} else {
			suffixParts = append(suffixParts, regexp.QuoteMeta(suffixPattern))
		}
	}
	suffixPart := strings.Join(suffixParts, "|")

	// The pattern is: (prefix)(ResourceName)(suffix)
	// e.g. GetUsersRoute, PostSomethingRouteV2
	// ResourceName is optional (e.g. `GetRoute`), capitalized, and can contain numbers.
	resourceNamePart := "([A-Z][a-zA-Z0-9]*)?"

	fullPattern := fmt.Sprintf("^(%s)%s(%s)$", prefixPart, resourceNamePart, suffixPart)
	routeRegex, err := regexp.Compile(fullPattern)
	if err != nil {
		log.Fatalf("Failed to compile route regex: %v", err)
	}

	set := token.NewFileSet()

	err = filepath.Walk(pathHandlersRoot, func(path string, f os.FileInfo, err error) error {
		if err != nil {
			fmt.Printf("Failed to access path %q: %v\n", path, err)
			os.Exit(1)
		}

		if path == pathHandlersFile || f.IsDir() || !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}

		gofile, err := parser.ParseFile(set, path, nil, 0)
		if err != nil {
			fmt.Println("Failed to parse package:", err)
			os.Exit(1)
		}

		fileDir := filepath.Dir(path)
		packageNameFQDN := strings.Replace(fileDir, pathProjectRoot, baseModuleName, 1)

		for _, d := range gofile.Decls {
			if fn, isFn := d.(*ast.FuncDecl); isFn {
				fnName := fn.Name.String()
				if routeRegex.MatchString(fnName) {
					funcs = append(funcs, ResolvedFunction{
						FunctionName:    fnName,
						PackageName:     gofile.Name.Name,
						PackageNameFQDN: packageNameFQDN,
					})
					// A function matched, so we need to import its package.
					subPkgsMap[packageNameFQDN] = struct{}{}
				}
			}
		}
		return nil
	})

	if err != nil {
		log.Fatal(err)
	}

	// stable sort the functions: first PackageName then FunctionName
	sort.Slice(funcs[:], func(i, j int) bool {
		if funcs[i].PackageNameFQDN != funcs[j].PackageNameFQDN {
			return funcs[i].PackageNameFQDN < funcs[j].PackageNameFQDN
		}
		return funcs[i].FunctionName < funcs[j].FunctionName
	})

	// Create a slice of package FQDNs from the map.
	subPkgs := make([]string, 0, len(subPkgsMap))
	for pkgFQDN := range subPkgsMap {
		subPkgs = append(subPkgs, pkgFQDN)
	}
	sort.Strings(subPkgs) // Sort package imports alphabetically

	if printOnly {
		for _, function := range funcs {
			fmt.Println(function.PackageNameFQDN, function.FunctionName)
		}
		// bailout
		return
	}

	// Create and write the handlers.go file
	f, err := os.Create(pathHandlersFile)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	if err = packageTemplate.Execute(f, TempateData{
		SubPkgs: subPkgs,
		Funcs:   funcs,
	}); err != nil {
		log.Fatal(err)
	}
}
