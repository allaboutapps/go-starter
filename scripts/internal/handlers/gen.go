//go:build scripts

// This program generates /internal/api/handlers.go.
// It can be invoked by running go run -tags scripts scripts/handlers/gen_handlers.go

// Supported args:
// -print-only

package handlers

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"allaboutapps.dev/aw/go-starter/scripts/internal/util"
)

// https://blog.carlmjohnson.net/post/2016-11-27-how-to-use-go-generate/

var (
	handlersPackage = "/internal/api/handlers"

	pathProjectRoot  = util.GetProjectRootDir()
	pathHandlersRoot = pathProjectRoot + handlersPackage
	pathModFile      = pathProjectRoot + "/go.mod"
	pathHandlersFile = pathHandlersRoot + "/handlers.go"

	// methodPrefixes defines all keywords that we search for in the handlers sub packages
	// <methodPrefixes>*<methodSuffix> must be the naming of the route (Capitalized)
	methodPrefixes = []string{
		// https://swagger.io/specification/v2/ fixed fields: GET, PUT, POST, DELETE, OPTIONS, HEAD, PATCH
		"Get", "Put", "Post", "Delete", "Options", "Head", "Patch",
	}
	methodSuffixes = []string{
		"Route", "RouteV*", // Wildcard '*' matches zero or more digits
	}

	packageTemplate = template.Must(template.New("").Parse(`// Code generated by go run -tags scripts scripts/handlers/gen_handlers.go; DO NOT EDIT.
package handlers

import (
	"allaboutapps.dev/aw/go-starter/internal/api"
	{{- range .SubPkgs }}
	"{{ . }}"
	{{- end }}
	"github.com/labstack/echo/v4"
)

func AttachAllRoutes(s *api.Server) {
	// attach our routes
	s.Router.Routes = []*echo.Route{
		{{- range .Funcs }}
		{{ .PackageName }}.{{ .FunctionName }}(s),
		{{- end }}
	}
}
`))
)

type ResolvedFunction struct {
	FunctionName    string
	PackageName     string
	PackageNameFQDN string
}

type TempateData struct {
	SubPkgs []string
	Funcs   []ResolvedFunction
}

// get all functions in above handler packages
// that match <methodPrefixes>*<methodSuffix>
func GenHandlers(printOnly bool) {
	funcs := []ResolvedFunction{}

	baseModuleName, err := util.GetModuleName(pathModFile)
	if err != nil {
		log.Fatal(err)
	}

	// Build regex patterns
	regexPatterns := []string{}
	for _, prefix := range methodPrefixes {
		for _, suffixPattern := range methodSuffixes {
			var pattern string
			if strings.HasSuffix(suffixPattern, "*") {
				baseSuffix := suffixPattern[:len(suffixPattern)-1]
				// Regex: Start, Prefix, Optional(UpperCaseLetter, AnyAlphaNum*), BaseSuffix, Digits*, End
				pattern = fmt.Sprintf(`^%s([A-Z][a-zA-Z0-9]*)?%s[0-9]*$`, prefix, regexp.QuoteMeta(baseSuffix))
			} else {
				// Regex: Start, Prefix, Optional(UpperCaseLetter, AnyAlphaNum*), Suffix, End
				pattern = fmt.Sprintf(`^%s([A-Z][a-zA-Z0-9]*)?%s$`, prefix, regexp.QuoteMeta(suffixPattern))
			}
			regexPatterns = append(regexPatterns, pattern)
		}
	}

	// Sort patterns: Longer patterns first (heuristic for specificity)
	sort.Slice(regexPatterns, func(i, j int) bool {
		return len(regexPatterns[i]) > len(regexPatterns[j])
	})

	// Compile regexes
	compiledRegexes := make([]*regexp.Regexp, 0, len(regexPatterns))
	for _, p := range regexPatterns {
		re, err := regexp.Compile(p)
		if err != nil {
			log.Fatalf("Failed to compile regex '%s': %v", p, err)
		}
		compiledRegexes = append(compiledRegexes, re)
	}

	set := token.NewFileSet()
	packageInfoCache := make(map[string]struct{ Name, FQDN string }) // Cache package info

	err = filepath.Walk(pathHandlersRoot, func(path string, f os.FileInfo, err error) error {
		if err != nil {
			fmt.Printf("Failed to access path %q: %v\n", path, err)
			os.Exit(1)
		}

		// ignore handler file to be generated, directories, non-go files, test files
		if path == pathHandlersFile || f.IsDir() || !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "test.go") {
			return nil
		}

		// Parse the file to get declarations
		gofile, err := parser.ParseFile(set, path, nil, 0)
		if err != nil {
			fmt.Println("Failed to parse package:", err)
			os.Exit(1)
		}

		// Get package info (use cache)
		fileDir := filepath.Dir(path)
		packageNameFQDN := strings.Replace(fileDir, pathProjectRoot, baseModuleName, 1)
		pkgInfo, ok := packageInfoCache[packageNameFQDN]
		if !ok {
			pkgInfo = struct{ Name, FQDN string }{Name: gofile.Name.Name, FQDN: packageNameFQDN}
			packageInfoCache[packageNameFQDN] = pkgInfo
		}

		// Iterate through declarations and match function names
		for _, d := range gofile.Decls {
			if fn, isFn := d.(*ast.FuncDecl); isFn {
				fnName := fn.Name.String()
				// Check against compiled regexes (longest/most specific first)
				for _, re := range compiledRegexes {
					if re.MatchString(fnName) {
						funcs = append(funcs, ResolvedFunction{
							FunctionName:    fnName,
							PackageName:     pkgInfo.Name,
							PackageNameFQDN: pkgInfo.FQDN,
						})
						// Found the most specific match, stop checking regexes for this function
						break
					}
				}
			}
		}
		return nil
	})

	if err != nil {
		log.Fatal(err)
	}

	// Remove duplicates (if any regexes overlap unexpectedly)
	uniqueFuncsMap := make(map[string]ResolvedFunction)
	for _, fun := range funcs {
		key := fun.PackageNameFQDN + "." + fun.FunctionName
		uniqueFuncsMap[key] = fun
	}
	uniqueFuncs := make([]ResolvedFunction, 0, len(uniqueFuncsMap))
	for _, fun := range uniqueFuncsMap {
		uniqueFuncs = append(uniqueFuncs, fun)
	}
	funcs = uniqueFuncs // Replace original funcs with unique ones

	// stable sort the functions: first PackageName then FunctionName
	sort.Slice(funcs[:], func(i, j int) bool {
		if funcs[i].PackageNameFQDN != funcs[j].PackageNameFQDN {
			return funcs[i].PackageNameFQDN < funcs[j].PackageNameFQDN
		}
		return funcs[i].FunctionName < funcs[j].FunctionName
	})

	// Collect unique subpackage FQDNs that have matched functions
	subPkgsMap := make(map[string]struct{})
	for _, fun := range funcs {
		subPkgsMap[fun.PackageNameFQDN] = struct{}{}
	}
	subPkgs := make([]string, 0, len(subPkgsMap))
	for pkgFQDN := range subPkgsMap {
		subPkgs = append(subPkgs, pkgFQDN)
	}
	sort.Strings(subPkgs) // Sort package imports alphabetically

	if printOnly {
		for _, function := range funcs {
			fmt.Println(function.PackageNameFQDN, function.FunctionName)
		}
		// bailout
		return
	}

	// Create and write the handlers.go file
	f, err := os.Create(pathHandlersFile)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	if err = packageTemplate.Execute(f, TempateData{
		SubPkgs: subPkgs,
		Funcs:   funcs,
	}); err != nil {
		log.Fatal(err)
	}
}
